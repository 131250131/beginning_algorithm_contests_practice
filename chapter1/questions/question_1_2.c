#include<stdio.h>
#include<math.h>

// 问题2:double型浮点数能精确到多少位小数?或者，这个问题本身值得商榷?

// 实验思路：利用pi这个无理数，观察能精确表示多少位有效小数？

// 实验输出：pi这边只有前15位是精确的，之后的数字不稳定。

// 3.141593
// 0.0314159265358979339355371962483332026749849319458007812500000000000000000000000000000000000000000000
// 0.3141592653589793115997963468544185161590576171875000000000000000000000000000000000000000000000000000
// 3.1415926535897931159979634685441851615905761718750000000000000000000000000000000000000000000000000000
// 31.4159265358979311599796346854418516159057617187500000000000000000000000000000000000000000000000000000
// 314.1592653589793258106510620564222335815429687500000000000000000000000000000000000000000000000000000000
// 3141.5926535897929170459974557161331176757812500000000000000000000000000000000000000000000000000000000000

// (我的)回答
：15-16位。之后的数字虽然不为0，但并不精确。Double precision (double) gives you 52 bits of significand, 11 bits of exponent, and 1 sign bit.


// 公开讨论： https://stackoverflow.com/questions/5098558/float-vs-double-precision


int main() {
	double const pi = acos(-1.0);
	printf("%f\n", pi);
	printf("%0.100f\n", pi * 0.01);
	printf("%0.100f\n", pi * 0.1);
	printf("%0.100f\n", pi * 1);
	printf("%0.100f\n", pi * 10);
	printf("%0.100f\n", pi * 100);
	printf("%0.100f\n", pi * 1000);
}